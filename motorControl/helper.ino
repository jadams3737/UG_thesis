#include "MotorControl.hpp"

void setupMotors(AccelStepper &stepper)
{
    stepper.setAcceleration(500);
    stepper.setMaxSpeed(800);     // Was originally 1000
    stepper.setCurrentPosition(0);   // max position 8242
    stepper.setSpeed(0);
}

void stopAtEnds(long velocity, AccelStepper &stepper)
{
  long position = stepper.currentPosition();
  long buffer = 50;

  if (abs(position) < maxPosition) {
    // Do nothing, current position is valid
    // Serial.println("Case 1");
  }
  else if (position >= maxPosition && velocity <= 0) {
    // Do nothing, set velocity will take it away from +maxPosition
    // Serial.println("Case 2");
  }
  else if (position <= -maxPosition && velocity >= 0) {
    // Do nothing, set velocity will take it away from -maxPosition
    // Serial.println("Case 3");
  }
  else if (goToPos == true && abs(stepper.targetPosition()) < maxPosition) {
    // Do nothing, target position is valid
    // Serial.println("Case 4");
  }
  else {
    stepper.stop();
    stepper.setSpeed(0);
    // Serial.println("Case 5");
  }
}

float pid(int current, int set_point){
    float error = set_point - current;
    float Kp_float = 0.01 * float(K_p);   // Have had trouble passing floats through Serial
    float signal = Kp_float*error;    // Using only Proportional term at this stage
    return signal;
}

float lqr(int pitch, int roll, int pitch_OP, int roll_OP){
  // Not yet implemented
  
  int theta = pitch;
  // int theta_dot = change in pitch - I could record current and previous theta and the time elapsed using millis() and calculate velocity
  int phi = roll;
  // int phi_dot = change in roll - Same as above re: theta_dot
  int x = position1;
  // int x_dot = change in x - Same as above re: theta_dot
  int y = position2;
  // int y_dot = change in y - Same as above re: theta_dot

  // BLA::Matrix<8, 1> X = {   // Current State
  // theta,      // Pitch angle
  // theta_dot,  // Pitch velocity
  // phi,        // Roll angle
  // phi_dot,    // Roll velocity
  // x,          // position along fore-aft axis
  // x_dot,      // velocity along fore-aft axis
  // y,          // position along port-starboard axis
  // y_dot,      // velocity along port-starboard

  BLA::Matrix<8, 1> OP = {   // Operating Point (target point)
  pitch_OP,     // Pitch angle
  0,    // Pitch velocity
  roll_OP,      // Roll angle
  0,    // Roll velocity
  0,    // position along fore-aft axis
  0,    // velocity along fore-aft axis
  0,    // position along port-starboard axis - ??? Same as above for roll angle
  0,    // velocity along port-starboard

  // U = K * E;
  // F_x = Force generated by acceleration along x
  // F_y = Force generated by acceleration along y
};


}
